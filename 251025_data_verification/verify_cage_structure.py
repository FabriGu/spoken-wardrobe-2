"""
Cage Structure Verification Script
==================================
Analyzes the cage generated by the current system.

Usage:
    python 251025_data_verification/verify_cage_structure.py
"""

import sys
from pathlib import Path
import numpy as np
import trimesh

# Add parent directory and tests directory to path
project_root = Path(__file__).parent.parent
sys.path.append(str(project_root))
sys.path.append(str(project_root / "tests"))

# Import from main system
from enhanced_cage_utils import BodyPixCageGenerator
from tf_bodypix.api import download_model, load_model, BodyPixModelPaths
import cv2


def analyze_cage_structure(cage, mesh=None):
    """
    Analyze cage structure and report findings.
    
    Args:
        cage: Trimesh cage object
        mesh: Optional trimesh mesh object for comparison
    """
    print("\n" + "="*70)
    print("CAGE STRUCTURE ANALYSIS")
    print("="*70)
    
    # Basic stats
    print(f"\nðŸ“Š Basic Statistics:")
    print(f"   Cage vertices: {len(cage.vertices)}")
    print(f"   Cage faces: {len(cage.faces)}")
    
    if mesh:
        print(f"   Mesh vertices: {len(mesh.vertices)}")
        print(f"   Ratio: 1 cage vertex per {len(mesh.vertices)/len(cage.vertices):.1f} mesh vertices")
    
    # Cage bounds
    print(f"\nðŸ“ Cage Bounding Box:")
    bounds = cage.bounds
    size = bounds[1] - bounds[0]
    print(f"   Min: [{bounds[0][0]:.3f}, {bounds[0][1]:.3f}, {bounds[0][2]:.3f}]")
    print(f"   Max: [{bounds[1][0]:.3f}, {bounds[1][1]:.3f}, {bounds[1][2]:.3f}]")
    print(f"   Size: [{size[0]:.3f}, {size[1]:.3f}, {size[2]:.3f}]")
    
    # Check if mesh is bounded by cage
    if mesh:
        mesh_in_cage = check_mesh_in_cage(mesh, cage)
        if mesh_in_cage:
            print(f"   âœ“ Mesh is fully enclosed by cage")
        else:
            print(f"   âœ— WARNING: Mesh extends outside cage!")
    
    # Vertex distribution analysis
    print(f"\nðŸ” Vertex Distribution:")
    analyze_vertex_clustering(cage)
    
    # Connectivity analysis
    print(f"\nðŸ”— Connectivity:")
    print(f"   Watertight: {cage.is_watertight}")
    print(f"   Euler characteristic: {cage.euler_number}")
    
    # Quality assessment
    print(f"\nâ­ Quality Assessment:")
    assess_cage_quality(cage, mesh)
    
    print("\n" + "="*70)


def check_mesh_in_cage(mesh, cage):
    """Check if all mesh vertices are inside the cage."""
    # Simple bounding box check
    mesh_bounds = mesh.bounds
    cage_bounds = cage.bounds
    
    return (np.all(mesh_bounds[0] >= cage_bounds[0] - 0.01) and 
            np.all(mesh_bounds[1] <= cage_bounds[1] + 0.01))


def analyze_vertex_clustering(cage):
    """Analyze how vertices are distributed spatially."""
    vertices = cage.vertices
    
    # Compute pairwise distances
    from scipy.spatial.distance import pdist, squareform
    distances = squareform(pdist(vertices))
    
    # Find average nearest neighbor distance
    np.fill_diagonal(distances, np.inf)
    nearest_distances = distances.min(axis=1)
    
    print(f"   Mean nearest neighbor distance: {nearest_distances.mean():.4f}")
    print(f"   Std nearest neighbor distance: {nearest_distances.std():.4f}")
    print(f"   Min nearest neighbor distance: {nearest_distances.min():.4f}")
    print(f"   Max nearest neighbor distance: {nearest_distances.max():.4f}")
    
    # Check for potential anatomical sections by clustering
    from sklearn.cluster import KMeans
    n_clusters_to_try = [4, 6, 8]
    
    print(f"\n   Clustering Analysis (potential body part sections):")
    for n_clusters in n_clusters_to_try:
        kmeans = KMeans(n_clusters=n_clusters, random_state=42, n_init=10)
        labels = kmeans.fit_predict(vertices)
        cluster_sizes = [np.sum(labels == i) for i in range(n_clusters)]
        print(f"   {n_clusters} clusters: sizes = {cluster_sizes}")


def assess_cage_quality(cage, mesh):
    """Assess cage quality based on research criteria."""
    num_verts = len(cage.vertices)
    
    # Criterion 1: Low resolution (30-60 vertices ideal)
    if 30 <= num_verts <= 60:
        print(f"   âœ“ Vertex count ({num_verts}) is in ideal range [30-60]")
    elif 60 < num_verts <= 150:
        print(f"   âš  Vertex count ({num_verts}) is acceptable but higher than ideal")
    else:
        print(f"   âœ— Vertex count ({num_verts}) is too high! Should be 30-60 for clothing")
    
    # Criterion 2: Watertight
    if cage.is_watertight:
        print(f"   âœ“ Cage is watertight")
    else:
        print(f"   âœ— WARNING: Cage has holes!")
    
    # Criterion 3: Check for anatomical structure
    # Simple heuristic: good cages have some sections with 6-8 vertices
    vertices = cage.vertices
    if len(vertices) > 150:
        print(f"   âœ— Too many vertices suggests lack of anatomical structure")
        print(f"      â†’ Cage might be a dense convex hull instead of anatomical sections")
    else:
        print(f"   ? Cannot determine if anatomical structure exists from vertex count alone")
        print(f"      â†’ Need to visualize or check vertex groupings by body part")


def test_with_simple_mesh():
    """Test with a simple mesh to verify cage generation."""
    print("\n" + "="*70)
    print("TESTING WITH SIMPLE TEST MESH")
    print("="*70)
    
    # Create simple test mesh (from test_integration.py)
    vertices = []
    width, height, depth = 0.4, 0.6, 0.15
    
    for z_offset in [-depth/2, depth/2]:
        for y in np.linspace(0, height, 8):
            for x in np.linspace(-width/2, width/2, 6):
                x_curved = x * (1 + 0.1 * np.sin(y * np.pi / height))
                vertices.append([x_curved, y, z_offset])
    
    vertices = np.array(vertices)
    from scipy.spatial import ConvexHull
    hull = ConvexHull(vertices)
    mesh = trimesh.Trimesh(vertices=vertices, faces=hull.simplices)
    mesh.vertices -= mesh.vertices.mean(axis=0)
    mesh.vertices /= np.max(np.linalg.norm(mesh.vertices, axis=1))
    
    print(f"\nâœ“ Created test mesh: {len(mesh.vertices)} vertices, {len(mesh.faces)} faces")
    
    # Initialize BodyPix (needed for cage generation)
    print(f"\nLoading BodyPix model...")
    bodypix_model = load_model(download_model(
        BodyPixModelPaths.MOBILENET_FLOAT_50_STRIDE_16
    ))
    print(f"âœ“ BodyPix loaded")
    
    # Create dummy segmentation data
    print(f"\nGenerating dummy segmentation (640x480)...")
    frame = np.ones((480, 640, 3), dtype=np.uint8) * 128
    result = bodypix_model.predict_single(frame)
    person_mask = result.get_mask(threshold=0.75)
    
    # Get masks (already numpy arrays)
    person_mask_np = person_mask.numpy() if hasattr(person_mask, 'numpy') else person_mask
    colored_mask = result.get_colored_part_mask(person_mask)
    colored_mask_np = colored_mask.numpy() if hasattr(colored_mask, 'numpy') else colored_mask
    
    torso_mask = result.get_part_mask(person_mask, part_names=['torso_front', 'torso_back'])
    torso_mask_np = torso_mask.numpy() if hasattr(torso_mask, 'numpy') else torso_mask
    
    left_arm_mask = result.get_part_mask(person_mask, part_names=['left_upper_arm_front', 'left_upper_arm_back'])
    left_arm_mask_np = left_arm_mask.numpy() if hasattr(left_arm_mask, 'numpy') else left_arm_mask
    
    segmentation_data = {
        'person_mask': person_mask_np.astype(np.uint8),
        'colored_mask': colored_mask_np.astype(np.uint8),
        'body_parts': {
            'torso': torso_mask_np.astype(np.uint8),
            'left_upper_arm': left_arm_mask_np.astype(np.uint8),
        }
    }
    
    # Generate cage
    print(f"\nGenerating cage...")
    cage_generator = BodyPixCageGenerator(mesh)
    cage, cage_structure = cage_generator.generate_anatomical_cage(
        segmentation_data, 
        frame.shape,
        subdivisions=3
    )
    
    print(f"\nðŸ“‹ Cage Structure:")
    for part_name, part_info in cage_structure.items():
        print(f"   {part_name}: {len(part_info['vertex_indices'])} vertices, keypoints: {part_info['keypoints']}")
    
    # Analyze cage
    analyze_cage_structure(cage, mesh)
    
    # Save for visualization
    output_dir = Path(__file__).parent / "output"
    output_dir.mkdir(exist_ok=True)
    
    mesh.export(str(output_dir / "test_mesh.obj"))
    cage.export(str(output_dir / "test_cage.obj"))
    
    print(f"\nâœ“ Saved mesh and cage to: {output_dir}/")
    print(f"   â†’ You can open these in Blender/MeshLab to visualize")


def test_with_actual_mesh():
    """Test with actual generated 3D clothing mesh."""
    # Try the default mesh path first
    mesh_path = Path(__file__).parent.parent / "generated_meshes" / "0" / "mesh.obj"
    
    if not mesh_path.exists():
        # Fall back to other mesh
        mesh_path = Path(__file__).parent.parent / "generated_meshes" / "1_flames_clothing_triposr.obj"
    
    if not mesh_path.exists():
        print(f"\nâš  Actual mesh not found at: {mesh_path}")
        print(f"   Skipping actual mesh test...")
        return
    
    print("\n" + "="*70)
    print("TESTING WITH ACTUAL CLOTHING MESH")
    print("="*70)
    print(f"\nLoading mesh from: {mesh_path}")
    
    mesh = trimesh.load(str(mesh_path))
    print(f"âœ“ Loaded mesh: {len(mesh.vertices)} vertices, {len(mesh.faces)} faces")
    
    # Initialize BodyPix
    print(f"\nLoading BodyPix model...")
    bodypix_model = load_model(download_model(
        BodyPixModelPaths.MOBILENET_FLOAT_50_STRIDE_16
    ))
    
    # Create dummy segmentation
    print(f"\nGenerating dummy segmentation...")
    frame = np.ones((480, 640, 3), dtype=np.uint8) * 128
    result = bodypix_model.predict_single(frame)
    person_mask = result.get_mask(threshold=0.75)
    
    # Get masks (already numpy arrays)
    person_mask_np = person_mask.numpy() if hasattr(person_mask, 'numpy') else person_mask
    colored_mask = result.get_colored_part_mask(person_mask)
    colored_mask_np = colored_mask.numpy() if hasattr(colored_mask, 'numpy') else colored_mask
    torso_mask = result.get_part_mask(person_mask, part_names=['torso_front', 'torso_back'])
    torso_mask_np = torso_mask.numpy() if hasattr(torso_mask, 'numpy') else torso_mask
    
    segmentation_data = {
        'person_mask': person_mask_np.astype(np.uint8),
        'colored_mask': colored_mask_np.astype(np.uint8),
        'body_parts': {
            'torso': torso_mask_np.astype(np.uint8),
        }
    }
    
    # Generate cage
    print(f"\nGenerating cage...")
    cage_generator = BodyPixCageGenerator(mesh)
    cage, cage_structure = cage_generator.generate_anatomical_cage(
        segmentation_data,
        frame.shape,
        subdivisions=3
    )
    
    print(f"\nðŸ“‹ Cage Structure:")
    for part_name, part_info in cage_structure.items():
        print(f"   {part_name}: {len(part_info['vertex_indices'])} vertices, keypoints: {part_info['keypoints']}")
    
    # Analyze cage
    analyze_cage_structure(cage, mesh)
    
    # Save
    output_dir = Path(__file__).parent / "output"
    output_dir.mkdir(exist_ok=True)
    
    cage.export(str(output_dir / "actual_cage.obj"))
    print(f"\nâœ“ Saved cage to: {output_dir}/actual_cage.obj")
    print(f"   â†’ Open alongside your original mesh to compare")


def main():
    """Main verification function."""
    print("\n" + "="*70)
    print("CAGE STRUCTURE VERIFICATION TOOL")
    print("="*70)
    print("\nThis tool analyzes the cage generated by your current system")
    print("to identify structural issues.\n")
    
    # Test with simple mesh first
    test_with_simple_mesh()
    
    # Test with actual mesh if available
    test_with_actual_mesh()
    
    print("\n" + "="*70)
    print("VERIFICATION COMPLETE")
    print("="*70)
    print("\nðŸ“‹ Next Steps:")
    print("   1. Open output/*.obj files in Blender/MeshLab")
    print("   2. Check if cage has clear anatomical sections")
    print("   3. Count vertices in each section (should be ~6-8)")
    print("   4. If cage has 400+ vertices â†’ Problem confirmed!")
    print("\n   See: docs/251025_steps_forward.md for implementation plan")
    print("="*70 + "\n")


if __name__ == "__main__":
    main()

