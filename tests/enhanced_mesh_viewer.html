<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BodyPix Cage Deformation Viewer</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: white;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #info-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            min-width: 250px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #status {
            color: #00ff00;
            font-weight: bold;
            font-size: 16px;
        }
        
        .disconnected {
            color: #ff0000 !important;
        }
        
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .control-button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 8px 12px;
            margin: 5px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .control-button:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.4);
        }
        
        .control-button.active {
            background: rgba(0, 255, 255, 0.3);
            border-color: #00ffff;
        }
        
        .controls-info {
            background-color: #2a2a2a;
            padding: 15px;
            margin: 10px 0;
            border-radius: 8px;
            border: 1px solid #444;
        }
        
        .controls-info h3 {
            margin: 0 0 10px 0;
            color: #fff;
            font-size: 14px;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .control-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
        }
        
        .key {
            background-color: #444;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
            color: #fff;
            min-width: 30px;
            text-align: center;
        }
        
        .action {
            color: #ccc;
            margin-left: 10px;
        }
        
        #debug-panel {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-width: 400px;
            max-height: 300px;
            overflow-y: auto;
            display: none;
        }
        
        #debug-panel.visible {
            display: block;
        }
        
        .debug-section {
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .debug-section:last-child {
            border-bottom: none;
        }
        
        .debug-title {
            font-weight: bold;
            color: #00ffff;
            margin-bottom: 5px;
        }
        
        .debug-value {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #cccccc;
        }
        
        #performance-chart {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            width: 300px;
            height: 200px;
        }
        
        .chart-container {
            width: 100%;
            height: 150px;
            position: relative;
        }
        
        .chart-line {
            position: absolute;
            bottom: 0;
            width: 2px;
            background: #00ff00;
            opacity: 0.8;
        }
        
        .loading-spinner {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top: 3px solid #00ffff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: translate(-50%, -50%) rotate(0deg); }
            100% { transform: translate(-50%, -50%) rotate(360deg); }
        }
        
        .notification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            text-align: center;
            display: none;
        }
        
        .notification.visible {
            display: block;
        }
    </style>
</head>
<body>
    <div id="container">
        <!-- Loading spinner -->
        <div id="loading-spinner" class="loading-spinner"></div>
        
        <!-- Notification -->
        <div id="notification" class="notification">
            <div id="notification-text"></div>
        </div>
        
        <!-- Info Panel -->
        <div id="info-panel">
            <div><strong>BodyPix Cage Deformation Viewer</strong></div>
            <div>Status: <span id="status" class="disconnected">Disconnected</span></div>
            <div>FPS: <span id="fps">0</span></div>
            <div>Vertices: <span id="vertex-count">0</span></div>
            <div>Faces: <span id="face-count">0</span></div>
            <div>Messages: <span id="message-count">0</span></div>
            <div>Uptime: <span id="uptime">0s</span></div>
        </div>
        
        <!-- Camera Controls Info -->
        <div class="controls-info">
            <h3>Camera Controls</h3>
            <div class="control-group">
                <div class="control-item">
                    <span class="key">Mouse</span>
                    <span class="action">Orbit around mesh</span>
                </div>
                <div class="control-item">
                    <span class="key">WASD</span>
                    <span class="action">Move camera</span>
                </div>
                <div class="control-item">
                    <span class="key">Q/E</span>
                    <span class="action">Move up/down</span>
                </div>
                <div class="control-item">
                    <span class="key">Scroll</span>
                    <span class="action">Zoom in/out</span>
                </div>
            </div>
        </div>
        
        <!-- Controls -->
        <div id="controls">
            <div style="margin-bottom: 10px; font-weight: bold;">Controls</div>
            <button class="control-button" id="toggle-debug">Debug</button>
            <button class="control-button" id="toggle-wireframe">Wireframe</button>
            <button class="control-button" id="toggle-keypoints">Keypoints</button>
            <button class="control-button active" id="toggle-cage">Show Cage</button>
            <button class="control-button" id="reset-camera">Reset Camera</button>
            <button class="control-button" id="request-stats">Stats</button>
        </div>
        
        <!-- Debug Panel -->
        <div id="debug-panel">
            <div class="debug-section">
                <div class="debug-title">Connection Info</div>
                <div class="debug-value" id="debug-connection"></div>
            </div>
            <div class="debug-section">
                <div class="debug-title">Mesh Info</div>
                <div class="debug-value" id="debug-mesh"></div>
            </div>
            <div class="debug-section">
                <div class="debug-title">Performance</div>
                <div class="debug-value" id="debug-performance"></div>
            </div>
            <div class="debug-section">
                <div class="debug-title">Server Stats</div>
                <div class="debug-value" id="debug-server"></div>
            </div>
        </div>
        
        <!-- Performance Chart -->
        <div id="performance-chart">
            <div style="margin-bottom: 10px; font-weight: bold;">Performance</div>
            <div class="chart-container" id="chart-container"></div>
        </div>
    </div>

    <!-- Three.js from CDN -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        // Global variables
        let scene, camera, renderer, mesh, geometry, wireframe;
        let cageMesh, cageGeometry, cageMaterial, cageWireframe;  // Cage visualization
        let ws;
        let frameCount = 0;
        let lastTime = Date.now();
        let messageCount = 0;
        let startTime = Date.now();
        let controls;  // OrbitControls
        
        // WASD movement controls
        const moveSpeed = 0.1;
        const keys = {
            w: false,
            a: false,
            s: false,
            d: false,
            q: false,
            e: false
        };
        
        // State
        let debugMode = false;
        let showCage = true;  // Toggle cage visibility
        let wireframeMode = false;
        let keypointsMode = false;
        let lastKeypointsObj = null;
        
        // Movement update function
        function updateCameraMovement() {
            const direction = new THREE.Vector3();
            const right = new THREE.Vector3();
            
            // Get camera direction vectors
            camera.getWorldDirection(direction);
            right.crossVectors(camera.up, direction).normalize();
            
            // Apply movement
            if (keys.w) {
                camera.position.addScaledVector(direction, moveSpeed);
            }
            if (keys.s) {
                camera.position.addScaledVector(direction, -moveSpeed);
            }
            if (keys.a) {
                camera.position.addScaledVector(right, moveSpeed);
            }
            if (keys.d) {
                camera.position.addScaledVector(right, -moveSpeed);
            }
            if (keys.q) {
                camera.position.y += moveSpeed;
            }
            if (keys.e) {
                camera.position.y -= moveSpeed;
            }
            
            if (controls) {
                controls.update();
            }
        }
        
        // Performance tracking
        let fpsHistory = [];
        let maxHistoryLength = 100;
        
        // Initialize the application
        function init() {
            console.log('Initializing BodyPix Cage Deformation Viewer...');
            
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);

            // Add lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);
            
            // Add helpers
            const axesHelper = new THREE.AxesHelper(1.5);
            scene.add(axesHelper);
            
            const gridHelper = new THREE.GridHelper(5, 20);
            scene.add(gridHelper);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(0, 0, 3);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('container').appendChild(renderer.domElement);
            
            // Add OrbitControls for camera movement (after renderer is created)
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 0.1;
            controls.maxDistance = 50;
            controls.maxPolarAngle = Math.PI;
            
            // Keyboard event listeners
            document.addEventListener('keydown', (event) => {
                const key = event.key.toLowerCase();
                if (keys.hasOwnProperty(key)) {
                    keys[key] = true;
                    event.preventDefault();
                }
            });
            
            document.addEventListener('keyup', (event) => {
                const key = event.key.toLowerCase();
                if (keys.hasOwnProperty(key)) {
                    keys[key] = false;
                    event.preventDefault();
                }
            });
            
            // Create initial mesh
            geometry = new THREE.BufferGeometry();
            const material = new THREE.MeshPhongMaterial({
                color: 0x00ff88,
                side: THREE.DoubleSide,
                flatShading: false,
                transparent: true,
                opacity: 0.8
            });
            
            mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);
            
            // Create wireframe
            const wireframeMaterial = new THREE.MeshBasicMaterial({
                color: 0x000000,
                wireframe: true,
                transparent: true,
                opacity: 0.3
            });
            wireframe = new THREE.Mesh(geometry, wireframeMaterial);
            mesh.add(wireframe);
            wireframe.visible = false;
            
            // Create cage mesh (for debugging)
            cageGeometry = new THREE.BufferGeometry();
            cageMaterial = new THREE.MeshBasicMaterial({
                color: 0xff00ff,  // Magenta
                wireframe: true,
                transparent: true,
                opacity: 0.5
            });
            cageMesh = new THREE.Mesh(cageGeometry, cageMaterial);
            scene.add(cageMesh);
            cageMesh.visible = showCage;
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
            
            // Setup controls
            setupControls();
            
            // Connect WebSocket
            connectWebSocket();
            
            // Start animation loop
            animate();
            
            // Hide loading spinner
            document.getElementById('loading-spinner').style.display = 'none';
            
            console.log('Initialization complete!');
        }
        
        function setupControls() {
            // Toggle debug mode
            document.getElementById('toggle-debug').addEventListener('click', () => {
                debugMode = !debugMode;
                document.getElementById('debug-panel').classList.toggle('visible', debugMode);
                document.getElementById('toggle-debug').classList.toggle('active', debugMode);
                
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({ type: 'toggle_debug' }));
                }
            });
            
            // Toggle wireframe
            document.getElementById('toggle-wireframe').addEventListener('click', () => {
                wireframeMode = !wireframeMode;
                wireframe.visible = wireframeMode;
                document.getElementById('toggle-wireframe').classList.toggle('active', wireframeMode);
            });
            
            // Toggle cage
            document.getElementById('toggle-cage').addEventListener('click', () => {
                showCage = !showCage;
                if (cageMesh) {
                    cageMesh.visible = showCage;
                }
                document.getElementById('toggle-cage').classList.toggle('active', showCage);
                console.log('Cage visibility:', showCage);
            });
            
            // Toggle keypoints
            document.getElementById('toggle-keypoints').addEventListener('click', () => {
                keypointsMode = !keypointsMode;
                document.getElementById('toggle-keypoints').classList.toggle('active', keypointsMode);
                
                if (!keypointsMode && lastKeypointsObj) {
                    scene.remove(lastKeypointsObj);
                    lastKeypointsObj = null;
                }
            });
            
            // Reset camera
            document.getElementById('reset-camera').addEventListener('click', () => {
                camera.position.set(0, 0, 3);
                camera.lookAt(0, 0, 0);
                controls.reset();
            });
            
            // Request stats
            document.getElementById('request-stats').addEventListener('click', () => {
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({ type: 'request_performance' }));
                }
            });
        }
        
        function connectWebSocket() {
            console.log('Connecting to WebSocket...');
            ws = new WebSocket('ws://localhost:8765');
            
            ws.onopen = () => {
                console.log('WebSocket connected');
                document.getElementById('status').textContent = 'Connected';
                document.getElementById('status').classList.remove('disconnected');
                showNotification('Connected to server', 'success');
            };
            
            ws.onmessage = (event) => {
                try {
                    console.log('📨 WebSocket message received, size:', event.data.length);
                    const data = JSON.parse(event.data);
                    messageCount++;
                    
                    console.log('Message type:', data.type);
                    console.log('Message data keys:', Object.keys(data));
                    
                    switch (data.type) {
                        case 'welcome':
                            console.log('Welcome message:', data.message);
                            showNotification('Welcome! Server ready.', 'success');
                            break;
                            
                        case 'mesh_update':
                            console.log('🔄 Processing mesh update...');
                            console.log('Vertices in message:', data.vertices ? data.vertices.length : 'undefined');
                            console.log('Faces in message:', data.faces ? data.faces.length : 'undefined');
                            console.log('Has cage data:', data.has_cage);
                            
                            // Update mesh
                            updateMesh(data.vertices, data.faces);
                            
                            // Update cage if available
                            if (data.has_cage && data.cage_vertices && data.cage_faces) {
                                console.log('Updating cage...');
                                updateCage(data.cage_vertices, data.cage_faces);
                            } else {
                                console.log('No cage data in this message');
                            }
                            
                            // Update metadata
                            if (data.metadata) {
                                updateDebugInfo(data.metadata);
                            }
                            break;
                            
                        case 'debug_info':
                            updateDebugPanel(data.debug_data);
                            break;
                            
                        case 'performance_stats':
                            updatePerformanceStats(data.stats);
                            break;
                            
                        case 'debug_toggled':
                            console.log('Debug mode toggled:', data.debug_mode);
                            break;
                            
                        default:
                            console.log('Unknown message type:', data.type);
                    }
                } catch (error) {
                    console.error('Error parsing WebSocket message:', error);
                    console.error('Raw message:', event.data);
                }
            };
            
            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
                document.getElementById('status').textContent = 'Error';
                document.getElementById('status').classList.add('disconnected');
                showNotification('WebSocket error occurred', 'error');
            };
            
            ws.onclose = () => {
                console.log('WebSocket disconnected');
                document.getElementById('status').textContent = 'Disconnected';
                document.getElementById('status').classList.add('disconnected');
                showNotification('Disconnected from server', 'warning');
                
                // Try to reconnect after 3 seconds (only if we were connected)
                if (ws && ws.readyState === WebSocket.CLOSED && ws.url) {
                    setTimeout(connectWebSocket, 3000);
                }
            };
        }
        
        function updateMesh(vertices, faces) {
            console.log('=== MESH UPDATE DEBUG ===');
            console.log('Vertices received:', vertices.length);
            console.log('Faces received:', faces.length);
            console.log('First few vertices:', vertices.slice(0, 3));
            console.log('First few faces:', faces.slice(0, 3));
            
            // Check if we have valid data
            if (!vertices || vertices.length === 0) {
                console.warn('No vertices received!');
                return;
            }
            
            if (!faces || faces.length === 0) {
                console.warn('No faces received!');
                return;
            }
            
            // Update geometry
            const verticesFlat = new Float32Array(vertices.flat());
            const facesFlat = new Uint16Array(faces.flat());
            
            console.log('Vertices flat array length:', verticesFlat.length);
            console.log('Faces flat array length:', facesFlat.length);

            // Update geometry
            geometry.setAttribute('position', new THREE.BufferAttribute(verticesFlat, 3));
            geometry.setIndex(new THREE.BufferAttribute(facesFlat, 1));
            geometry.computeVertexNormals();
            
            // Compute bounding box for debugging
            geometry.computeBoundingBox();
            const bbox = geometry.boundingBox;
            console.log('Mesh bounding box:', bbox.min, bbox.max);
            
            // Check if mesh is too small or offscreen
            const size = bbox.max.clone().sub(bbox.min);
            const maxSize = Math.max(size.x, size.y, size.z);
            console.log('Mesh size:', size);
            console.log('Max dimension:', maxSize);
            
            if (maxSize < 0.01) {
                console.warn('⚠️ Mesh is very small! Max dimension:', maxSize);
            }
            
            if (maxSize > 10) {
                console.warn('⚠️ Mesh is very large! Max dimension:', maxSize);
            }
            
            // Check if mesh center is far from origin
            const center = bbox.min.clone().add(bbox.max).multiplyScalar(0.5);
            const distanceFromOrigin = center.length();
            console.log('Mesh center:', center);
            console.log('Distance from origin:', distanceFromOrigin);
            
            if (distanceFromOrigin > 5) {
                console.warn('⚠️ Mesh center is far from origin! Distance:', distanceFromOrigin);
            }
            
            // Scale mesh if it's too small
            if (maxSize < 0.1) {
                const scaleFactor = 0.5 / maxSize;
                console.log('Scaling mesh by factor:', scaleFactor);
                mesh.scale.setScalar(scaleFactor);
            } else if (maxSize > 2) {
                const scaleFactor = 1.0 / maxSize;
                console.log('Scaling down mesh by factor:', scaleFactor);
                mesh.scale.setScalar(scaleFactor);
            } else {
                mesh.scale.setScalar(1.0);
            }
            
            // Center the mesh
            mesh.position.copy(center.negate());
            console.log('Mesh positioned at:', mesh.position);
            
            // Update display info
            document.getElementById('vertex-count').textContent = vertices.length;
            document.getElementById('face-count').textContent = faces.length;

            // Update FPS
            frameCount++;
            const now = Date.now();
            if (now - lastTime >= 1000) {
                const fps = frameCount / ((now - lastTime) / 1000);
                document.getElementById('fps').textContent = fps.toFixed(1);
                
                // Update FPS history
                fpsHistory.push(fps);
                if (fpsHistory.length > maxHistoryLength) {
                    fpsHistory.shift();
                }
                updatePerformanceChart();
                
                frameCount = 0;
                lastTime = now;
            }
            
            // Update uptime
            const uptime = Math.floor((Date.now() - startTime) / 1000);
            document.getElementById('uptime').textContent = uptime + 's';
            
            // Update message count
            document.getElementById('message-count').textContent = messageCount;
            
            console.log('=== MESH UPDATE COMPLETE ===');
        }
        
        function updateCage(cageVertices, cageFaces) {
            console.log('=== CAGE UPDATE DEBUG ===');
            console.log('Cage vertices received:', cageVertices ? cageVertices.length : 'none');
            console.log('Cage faces received:', cageFaces ? cageFaces.length : 'none');
            
            // Check if we have valid cage data
            if (!cageVertices || cageVertices.length === 0) {
                console.warn('No cage vertices received - hiding cage');
                if (cageMesh) cageMesh.visible = false;
                return;
            }
            
            if (!cageFaces || cageFaces.length === 0) {
                console.warn('No cage faces received - hiding cage');
                if (cageMesh) cageMesh.visible = false;
                return;
            }
            
            // Update cage geometry
            const cageVerticesFlat = new Float32Array(cageVertices.flat());
            const cageFacesFlat = new Uint16Array(cageFaces.flat());
            
            cageGeometry.setAttribute('position', new THREE.BufferAttribute(cageVerticesFlat, 3));
            cageGeometry.setIndex(new THREE.BufferAttribute(cageFacesFlat, 1));
            cageGeometry.computeVertexNormals();
            
            // Apply same transform as mesh to keep them aligned
            if (mesh) {
                cageMesh.position.copy(mesh.position);
                cageMesh.scale.copy(mesh.scale);
            }
            
            // Make cage visible if showCage is true
            cageMesh.visible = showCage;
            
            console.log('Cage updated successfully');
            console.log('=== CAGE UPDATE COMPLETE ===');
        }
        
        function updateDebugInfo(metadata) {
            if (!debugMode) return;
            
            // Update debug panel with mesh metadata
            const meshInfo = `Vertices: ${metadata.vertex_count || 'N/A'}\n` +
                           `Faces: ${metadata.face_count || 'N/A'}\n` +
                           `Timestamp: ${new Date(metadata.timestamp * 1000).toLocaleTimeString()}`;
            
            document.getElementById('debug-mesh').textContent = meshInfo;
        }
        
        function updateDebugPanel(debugData) {
            if (!debugMode) return;
            
            document.getElementById('debug-connection').textContent = 
                `Status: ${debugData.server_status}\n` +
                `Clients: ${debugData.clients_connected}\n` +
                `Debug Mode: ${debugData.debug_mode}`;
        }
        
        function updatePerformanceStats(stats) {
            if (!debugMode) return;
            
            const perfInfo = `Uptime: ${stats.uptime.toFixed(1)}s\n` +
                           `Messages: ${stats.messages_sent}\n` +
                           `Bytes: ${stats.bytes_sent}\n` +
                           `Avg Msg/sec: ${stats.avg_messages_per_sec.toFixed(2)}\n` +
                           `Avg Bytes/sec: ${stats.avg_bytes_per_sec.toFixed(2)}`;
            
            document.getElementById('debug-performance').textContent = perfInfo;
        }
        
        function updatePerformanceChart() {
            const container = document.getElementById('chart-container');
            container.innerHTML = '';
            
            if (fpsHistory.length < 2) return;
            
            const maxFps = Math.max(...fpsHistory);
            const minFps = Math.min(...fpsHistory);
            const range = maxFps - minFps || 1;
            
            fpsHistory.forEach((fps, index) => {
                const height = ((fps - minFps) / range) * 100;
                const left = (index / fpsHistory.length) * 100;
                
                const bar = document.createElement('div');
                bar.className = 'chart-line';
                bar.style.left = left + '%';
                bar.style.height = height + '%';
                bar.style.backgroundColor = fps > 20 ? '#00ff00' : fps > 10 ? '#ffff00' : '#ff0000';
                container.appendChild(bar);
            });
        }
        
        function showNotification(message, type = 'info') {
            const notification = document.getElementById('notification');
            const text = document.getElementById('notification-text');
            
            text.textContent = message;
            notification.className = `notification visible ${type}`;
            
            setTimeout(() => {
                notification.classList.remove('visible');
            }, 3000);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Update camera movement
            if (typeof updateCameraMovement === 'function') {
                updateCameraMovement();
            }
            
            // Rotate mesh slowly for better visualization
            if (mesh) {
                mesh.rotation.y += 0.005;
            }
            
            renderer.render(scene, camera);
        }
        
        // Start the application
        init();
    </script>
</body>
</html>
