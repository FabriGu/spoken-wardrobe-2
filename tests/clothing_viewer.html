<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Clothing Overlay - Real-Time</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: Arial, sans-serif;
        }

        #container {
            width: 100vw;
            height: 100vh;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #0f0;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 100;
        }

        #stats {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: #0f0;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            font-family: monospace;
        }

        .status {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
        }

        .status.connected {
            background: #0f0;
            box-shadow: 0 0 10px #0f0;
        }

        .status.disconnected {
            background: #f00;
        }
    </style>
</head>
<body>
    <div id="container"></div>

    <div id="info">
        <h3 style="margin: 0 0 10px 0;">ðŸŽ¨ AI Clothing Overlay</h3>
        <div>
            <span class="status disconnected" id="status"></span>
            <span id="statusText">Connecting...</span>
        </div>
        <div style="margin-top: 10px; font-size: 12px;">
            <strong>Controls:</strong><br>
            â€¢ Left Mouse: Rotate<br>
            â€¢ Right Mouse: Pan<br>
            â€¢ Scroll: Zoom<br>
            â€¢ 'r': Reset view
        </div>
    </div>

    <div id="stats">
        FPS: <span id="fps">0</span><br>
        Vertices: <span id="vertices">0</span><br>
        Faces: <span id="faces">0</span>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // === Three.js Setup ===
        let scene, camera, renderer, controls;
        let bodyMesh;
        let keypointSpheres = [];
        let ws;

        // Stats
        let frameCount = 0;
        let lastTime = Date.now();
        let fps = 0;

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);

            // Camera
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(0, 0, 2);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('container').appendChild(renderer.domElement);

            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.target.set(0, 0, 0);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);

            // Grid helper
            const gridHelper = new THREE.GridHelper(2, 20, 0x444444, 0x222222);
            scene.add(gridHelper);

            // Axes helper
            const axesHelper = new THREE.AxesHelper(0.5);
            scene.add(axesHelper);

            // Handle window resize
            window.addEventListener('resize', onWindowResize, false);

            // Keyboard controls
            document.addEventListener('keydown', (e) => {
                if (e.key === 'r' || e.key === 'R') {
                    camera.position.set(0, 0, 2);
                    controls.target.set(0, 0, 0);
                    controls.update();
                }
            });

            console.log('âœ“ Three.js initialized');
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function createBodyMesh(vertices, faces, colors) {
            // Remove old mesh
            if (bodyMesh) {
                scene.remove(bodyMesh);
                bodyMesh.geometry.dispose();
                bodyMesh.material.dispose();
            }

            // Create geometry
            const geometry = new THREE.BufferGeometry();

            // Convert vertices array to Float32Array
            const verticesFlat = new Float32Array(vertices.flat());
            geometry.setAttribute('position', new THREE.BufferAttribute(verticesFlat, 3));

            // Convert faces to indices
            const indicesFlat = new Uint32Array(faces.flat());
            geometry.setIndex(new THREE.BufferAttribute(indicesFlat, 1));

            // Convert colors (0-255 to 0-1)
            const colorsNormalized = colors.map(c => c.map(v => v / 255.0));
            const colorsFlat = new Float32Array(colorsNormalized.flat());
            geometry.setAttribute('color', new THREE.BufferAttribute(colorsFlat, 3));

            // Compute normals
            geometry.computeVertexNormals();

            // Material with vertex colors
            const material = new THREE.MeshPhongMaterial({
                vertexColors: true,
                side: THREE.DoubleSide,
                flatShading: false,
                shininess: 30
            });

            // Create mesh
            bodyMesh = new THREE.Mesh(geometry, material);

            // No flipping needed - Python sends corrected coordinates
            // bodyMesh.scale.set(1, -1, -1);

            scene.add(bodyMesh);

            // Update stats
            document.getElementById('vertices').textContent = vertices.length;
            document.getElementById('faces').textContent = faces.length;
        }

        function updateKeypoints(keypoints) {
            // Remove old spheres
            keypointSpheres.forEach(sphere => {
                scene.remove(sphere);
                sphere.geometry.dispose();
                sphere.material.dispose();
            });
            keypointSpheres = [];

            // Add new spheres
            if (keypoints && keypoints.length > 0) {
                const geometry = new THREE.SphereGeometry(0.02, 8, 8);
                const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });

                keypoints.forEach(([x, y, z]) => {
                    const sphere = new THREE.Mesh(geometry, material.clone());
                    sphere.position.set(x, y, z);
                    scene.add(sphere);
                    keypointSpheres.push(sphere);
                });
            }
        }

        function connectWebSocket() {
            console.log('Connecting to WebSocket...');
            ws = new WebSocket('ws://localhost:8765');

            ws.onopen = () => {
                console.log('âœ“ WebSocket connected');
                document.getElementById('status').classList.remove('disconnected');
                document.getElementById('status').classList.add('connected');
                document.getElementById('statusText').textContent = 'Connected';
            };

            ws.onmessage = (event) => {
                const message = JSON.parse(event.data);

                if (message.type === 'mesh_update') {
                    const { vertices, faces, colors } = message.data;
                    createBodyMesh(vertices, faces, colors);

                    // Update keypoints if available
                    if (message.keypoints) {
                        updateKeypoints(message.keypoints);
                    }
                }
            };

            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
            };

            ws.onclose = () => {
                console.log('WebSocket closed, reconnecting...');
                document.getElementById('status').classList.remove('connected');
                document.getElementById('status').classList.add('disconnected');
                document.getElementById('statusText').textContent = 'Disconnected';

                // Try to reconnect after 1 second
                setTimeout(connectWebSocket, 1000);
            };
        }

        function updateFPS() {
            frameCount++;
            const now = Date.now();
            const elapsed = now - lastTime;

            if (elapsed >= 1000) {
                fps = Math.round(frameCount / (elapsed / 1000));
                document.getElementById('fps').textContent = fps;
                frameCount = 0;
                lastTime = now;
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            // Update controls
            controls.update();

            // Render
            renderer.render(scene, camera);

            // Update FPS
            updateFPS();
        }

        // === Start ===
        init();
        connectWebSocket();
        animate();

        console.log('âœ“ Viewer ready');
        console.log('Waiting for mesh data...');
    </script>
</body>
</html>
